## Linux信号概述
- linux下，一个进程给其他进程发送信号的API是kill函数。
```c++
#include <sys/types.h>
#include <signal.h>
int kill(pid_t pid, int sig);
```
| pid参数 |	含义 |
|:--------:|:------|
| pid > 0 |发送给PID为pid1的进程|
| pid = 0  |信号发送给本进程组内的其他进程|
| pid = -1 | 信号发送给除了init进程外的所有进程，但需要权限|
| pid < -1 | 信号发送给组ID为-pid的进程组中的所有成员 |
- linux定义的信号都>0，如果sig取值为0，则kill函数不发送任何信号。但将sig设置为0可以用来检测目标进程或者进程组是否存在。
- 该函数成功时返回0，失败时返回-1并设置errno。
## 信号处理方式
```c++
#include <signal.h>
typedef void (* _sighandler_t) ( int );
```
```c++
#include <bits/signum.h>
#define SIG_DFL((_sighandler_t) 0);
#define SIG_IGN((_sighandler_t) 1);
```
- SIG_IGN表示忽略目标信号
- SIG_DFL表示使用信号的默认处理方式。
```c++
#include <signal.h>
_sighandler_t signal(int sig, _sighandler_t* _handler);
```
| 参数  | 含义|
|:----:|:----|
| sig  | 指出要捕获的信号类型 |
| act  | 指定新的信号处理方式 |
| oact | 输出信号先前的处理方式 |
- act 和 oact 都是sigaction结构体类型的指针。
```c++
struct sigaction
{
#ifdef _USE_POSIX199309
		union
		{
			//指定信号处理函数
			_sighandler_t sa_handler;
			
			void (*sa_sigaction)(int, siginfo_t*,void*);
		}
		_sigaction_handler;
# define sa_handler		_sigaction_handler.sa_handler;
# define sa_sigaction 		_sigaction_handler.sa_sigaction
#else
	_sighandler_t sa_handler;
#endif
	//在进程原有信号掩码的基础之上增加信号掩码，指定忽略那些信号
	_sigset_t sa_mask;
	int sa_flags;
	void (*sa_restorer) (void);
};
```
## 信号集
```c++
#include <bits/sigset.h>
# define _SIGSET_NWORDS (1024 / (8 * sizeof(unsigned long int )))
typedef struct
{
	unsigned long int _val[_SIGSET_NWORDS];
}_sigset_t;
```
- sigset_t 实际上是一个长整类数组，用位图表示每一种信号
```c++
#include <signal.h>
// 清空信号集
int  sigemptyset (sigset_t* _set);
// 在信号集中设置所有信号
int  sigfillset  (sigset_t* _set);
// 将信号 _signo 添加到信号
int  sigaddset   (sigset_t* _set,int _signo);
// 将信号 _signo 从信号集中删除
int  sigdelset   (sigset_t* _set,int _signo);
// 测试 _signo是否在信号集中
int  sigismember (_const sigset_t* _set, int _signo);
```
- 获得当前进程被挂起的信号集,成功返回-1，并设置errno
```c++
#include <signal.h>
int sigpending( sigset_t* set );
```
## 统一事件源
- 信号处理函数通常来使用管道来将信号传递给主循环：信号处理函数往管道的写端写入信号值，主循环则从管道读出该信号值。
## 网络编程相关信号
- SIGHUP
- SIGPIPE
- SIGURG
- SIGALRM
- 
