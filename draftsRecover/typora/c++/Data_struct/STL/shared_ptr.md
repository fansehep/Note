动态内存

## 智能指针


- 一.shared_ptr 与 unique_ptr 类共有属性
	- 1. 如果不传入对象，智能指针就是一个空指针
	- 2. p 将p当做一个条件进行判断，若不为空，则为真
	- 3. *P 解引用p，相当于获得他指向的对象
	- 4. get() 方法返回智能指针中保存的对象，`  `- 5. swap() 方法交换p和q中的指针
- 二. shared_ptr私有属性
	- 1. p = q;
		p的指针指向q的内容，p的引用计数-1，q的引用计数-1，
		当引用计数变为0的时候，会自动调用类的析构函数
	-2.p.unique()
		判断当前智能指针是否唯一
		当p的引用计数为1时，返回true，
		不为1时，返回false；
	-3.use_count()
		返回与p共享对象的智能指针数量，
- 三.make_shared 
	- 1.标准库函数中用于动态分配内存的函数，他是一个模板函数，所以在使用的时候必须加上类型，可以加上类的初始化条件。
```c++
		shread_ptr<int> p3 = make_shared<int>(42);
```
	- 1.shared_ptr都有一个关联的计数器，叫做引用计数，无论何
时，我们拷贝一个shared_ptr，计数器都会递增。
	-   2.例如，当我们用一个shared_ptr初始化另外一个shared_ptr时，或将他作为函数参数传入，或者作为函数的返回值，他所关联的计数器就会递增，当给一个shared_ptr赋一个新值时，或该shared_ptr被销毁时，或者局部的shared_ptr离开作用域时，计数器就会递减，一旦一个shared_ptr的计数器变为0，那么他就会自动释放自己管理的对象。
	- 3. 智能指针使用动态内存，对于一个普通由 new来申请空间的指针，在它离开他的作用域时，什么事情都不会发生，
	- 四 动态内存的管理需要非常谨慎
		- 1. 忘记delete掉内存，忘记释放动态内存会导致人们常说的 “内存泄露”的问题，这种问题是很难排查的，因为只有你的程序的内存被耗光时，才能检测到这种问题。
		-2. delete指针之后，必须将该指针置空
		-3. 智能指针的reset方法，现在重载了3个版本，这个你就不要管了.只要记住当你调用这个方法的智能指针只有1个，那么他就会自动调用他的析构函数。
		-4.智能指针会返回一个get方法，但请注意这个get返回的指针是不能够用delete释放了，
		- 5.但其实智能指针所包含的对象，不是所有的对象的析构函数是正确的，在c/c++里有一些类的设计是为了兼顾这两者，这可能需要你自己手写一个析构函数。