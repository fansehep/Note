### 共享内存
  共享内存( shared memory )允许同一个物理页在不同的应用程序间共享。
 - 例如，应用程序 A 的虚拟页 V1 呗映射到物理页 P，若应用程序 B 的虚拟页 V2也被映射到物理页 P，则物理页 P 是应用程序 A 和 应用程序 B 的共享内存。
 - 应用程序 A 能读取虚拟页 V1 和 应用程序B 读取 虚拟页 V2将得到相同的内容，互相也能看到对方修改的内容。
 - 共享内存可以让不同的程序之间互相通信，传递数据。
 - 基于这种共享内存的思想，操作系统又从中衍生出诸如**写实拷贝**和**内存去重**等功能
#### 这里引入 Linux / c下的一个函数
```c
#include <sys/mman.h>
void* mmap(void* addr, size_t length, int prot, \
				int flags, int fd, off_t offset );
void munmap(void* addr, size_t length);
/* mmap 用于创建内存映射文件的函数，用于实现文件磁盘地址和进程虚拟
地址空间中一段虚拟地址的一一对映关系。
进程可以采用指针的方式来读写这一段内存，而系统会自动会写到脏页面对
应的文件磁盘上。既完成了对文件的操作而不必再调用 Read Write等系统
调用函数。相反，内核空间对这段区域的修改也直接反映用户空间，从而可
以实现不同进程的文件共享。
*/
```
----
### 写时拷贝
请思考一下2个场景
```
1 ：两个应用程序拥有很多的相同的内存数据( 比如加载了相同的动态链接
库 ),如果把这些数据相同的内存页在物理内存中仅存出一份，然后以只读的
方式映射给两个应用程序，那么就能够显著的节约物理资源。
2 ：Linux中，一个应用程序可以用 fork 系统调用创建子程序，初始时，
父子程序的全部内存数据和地址空间完全一样。如何高效地实现这种应用程
序创建机制呢？
```
![](https://raw.githubusercontent.com/yangxiaofan369/img_HMStrange/master/2021-11-18%20194543.png)
```
  让我们回忆一下，我们一般的一个指针的前 12 位是不用的，那么剩下的位用来干嘛呢( 此处引入位图的概念 ),剩下的属性位用于标识虚拟页的权限( 该页是否可写，可执行 )的权限位等等。
```
那么问题也就来了，写时拷贝技术允许应用程序 A 和 应用程序 B 以 只读的方式 共享同一段物理内存。一旦某个应用程序对该内存区域进行修改，就会触发缺页异常。
！但这里的缺页异常不是由于违反权限所导致的。
操作系统发现有一个应用程序 write 了 一片 只读内存，那么操作系统就会把物理内存中缺页异常对应的物理页重新拷贝一份，并且将新拷贝的物理页以
可读可写的形式重新映射给触发异常的应用程序，再回复应用程序的执行。
### 内存去重
基于写时拷贝机制，操作系统进一步地设计了内存去重功能。操作系统可以定期地在内存中扫描具有相同的内容的物理页。并且找到映射到这些物理页的虚拟页；然后只保存其中一个物理页，并且将具有相同内容的其他虚拟页都用写时拷贝的方式来映射到这个物理页。
- 该功能通常由操作系统来实现
- 但其实又不过是 Trade off 罢了，内存去重功能会对应用程序访问内存延迟造成影响，当应用程序写一个被去重的内存页时，就会触发缺页异常，又会导致内存拷贝，从而可能导致性能下降。
### 内存压缩
为了节约内存资源，现代操作系统还引入了压缩算法来对内存数据进行压缩。
- 基本原理 : 当内存资源不充足的时候，操作系统选择一些 "最近不太会使用"的内存页，压缩其中的数据，从而释放更多的空闲内存
### 大页
- 在多级页表那篇博客中，我们知道，较高的 TLB 的命中率可以降低地址翻译的性能开销。由于翻译每个内存页都需要占用 一个 TLB 缓存项，CPU 中有限的 TLB 缓存项显得弥足珍贵。
- 大页机制能够有效的缓解 TLB 缓存项不够用的问题，大页的大小可以是 2MB 或者 1 GB。
- 这里不多赘述。
