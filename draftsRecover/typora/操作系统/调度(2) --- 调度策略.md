<span style="color: blue;">单核调度策略</span>

- 下面我们为大家介绍一些常见的，经典的调度策略。这些调度策略都假设当前 CPU 只有一个可用的 CPU 核心，每个任务都有自己的 <span style="color: red;"><span style="color: red;">到达事件 ( arrival time ) <span style="color: black;">和 <span style="color: red;">运行时间 ( run time )<span style="color: black;">, 到达时间用于表示该任务何时被发起并处于预备状态，运行时间用于表示该任务从何时执行到结束总共花费的时间。</span></span></span></span></span>
    - 在单核上进行调度时：调度器应该要回到以下两个问题:
        - 1.  当前应该调度哪个任务 ?
        - 2.  被调度的任务应该持久多少 ?

### 经典调度策略

- <span style="color: red;">先到先得</span>
    
    - 在调度策略中，一种比较直观的策略就是**先到先得** ( First Come First Served, FCFS )策略，这一类策略也被称之为**先进先出**( First In First Out, FIFO ) 策略。
        
    - 在该策略中，我们会在操作系统中维护一个运行队列，这个队列中的元素是处于预备状态，等待执行的任务。在决定需要执行的任务时，FCFS 策略会选取运行队列中的队尾，运行队列能够起到多个任务确定顺序的作用，保证任务的执行顺序与其进入运行队列的顺序一致。
        
    - FCFS 策略仅仅需要开发者维护一个队列，就可以实现 FCFS 策略，同时，FCFS策略不需要预知任务信息，也没有需要开发者手动调试的参数。但随着本章内容的不断深入，我们会意识到 FCFS 策略没有将许多重要因素纳入考量，从而导致他很难被直接在复杂系统中。不过，FCFS 的思想仍然在后面介绍的调度策略中得到了应用。
        
    - 弊端1 : 在长短任务混合的场景下对短任务支持不友好。在 短任务(短时话费任务) 与 长任务 ( 长时运行任务 )混合的应用场景下，FCFS策略可能会导致短任务的周转时间和运行时间之比过大，对短任务不友好。
        
    - 弊端2 : 对 IO 密集型任务不友好。 IO 密集型任务通常会花费大部分时间等待 IO，仅仅有少量的时间被用在 CPU 中处理请求。
        
- <span style="color: red;">最短任务优先</span>
    
    - FCFS 策略所面临的短任务等待时间过长的问题促使我们寻找另外一种调度策略。我们应该尽量让短任务立即执行。根据这一思想，得出的策略是<span style="color: blue;">最短任务优先<span style="color: black;">,该策略会选择运行时间最短的任务执行。
        ![](https://raw.githubusercontent.com/yangxiaofan369/img_HMStrange/master/gnome-shell-screenshot-Q2BUC1.png)</span></span>
    - 弊端 1: **必须预知任务的运行时间**。SJF 策略能选取最短运行时间或者固定的应用场景，这个前提是合理的。但是在更多的场景下，系统很难预知将要处理的任务确切的运行时间。因为这取决于当前系统的状态和其他影响程序性能的因素。
    - 弊端 2: **其表现严重依赖于任务到达时间点**,现在我们假设一个场景，一个任务时间比较长的任务A到达了，所以 A 会先运行，只有 任务B到达了，但是 任务 B只需要话费少量的时间，此时 调度器已经没有办法了。
- <span style="color: red;">最短完成时间任务优先</span>
    
    - SJF策略面临的问题是，"迟到"的短任务是无法受益于 SJF 策略的。为了解决这个问题，一个直接的思路是，是否可以让调度器在任务 B 和 C 之间对其进行调度，按照这个思路产生了 SJF 策略的抢占式版本 : **最短完成时间任务优先**( Shortest Time-to- Completion First, STCF ) 策略，在 FCFS 策略 和 SJF 策略中，调度器必须等一个任务执行完成或者主动退出执行才能开始下一个调度。因此被称为**非抢占式调度**( non-preemptive scheduling ) 。而 STCF 策略在任务到达系统时也会进行调度，有可能会中断当前正在执行的任务，转而执行其他的任务，因此被称为**抢占式调度**( preemptive scheduling )。
        ![](https://raw.githubusercontent.com/yangxiaofan369/img_HMStrange/master/gnome-shell-screenshot-UK26C1.png)
    - 任务 A 在第 0 秒到达了，B 和 C 稍后达到，由于 任务 A 在第 0 秒到达系统，所以A执行了 1S，在第一秒时，任务 B 到达系统，由于其所需要的时间少于 任务 A，所以 B 就可以立即抢占任务 A并执行。而当任务 C 在第2s到达时，任务 B 已经运行了 1s，**任务 B所需要的剩余时间**小于任务C的时间，所以 C就不会抢占 任务B的执行，而是会等到任务 B 结束后再开始执行。
    - 弊端 : 长任务饥饿 : STCF 策略极端倾向于完成时间较短的任务，因此当一个系统中有大量的短任务和少量的长任务时，这个系统的长任务很可能会无法占用 CPU 资源，一直处于**饥饿**状态 ( starvation ),即永远无法被调度。在某些系统中，通常会有后台服务( 例如 网络服务，数据库服务 ) 随开机启动，并一直执行，他们的运行时间相比于其他任务长很多。SJF策略和 STCF 策略几乎不会让他们获得执行机会，而这对整个系统调度的公平性是不利的。
- <span style="color: red;">时间片轮换</span>
    
    - 我们以上讨论的调度策略主要是针对批处理任务的策略，他们主要关注的调度指标是**周转时间**，随着操作系统的发展，交互式程序(终端)逐渐普及，与用户的交互为调度带来了新的调度指标 — **响应时间**。响应时间指的是从用户发起请求到任务响应用户所需要的时间。
    - 上文我们所讨论的策略只有在任务到达和结束时才会进行调度，如果一段时间内没有新的任务到达或者当前任务没有执行完，那么调度器就无法进行调度，因此非运行状态的任务也无法定时地响应用户。为了定时响应用户，需要为任务设置时间片，限定任务每次执行的时间。当前任务执行完时间片之后，就切换到运行队列中的下一个任务。这一思想的体现就是**时间片轮转( Round Robin, RR )策略**。由于时间片一般会设置的足够小，所以所有任务都可以在一定时间内执行并且响应用户，从而将响应时间限定在一个可接受的范围内。相比于**SJF**策略和**STCF**策略，RR策略使用无须直到任务的运行时间，而且也不会出现长任务饥饿的情况。
    - 对于 RR 策略，一个关键点就是他的时间片大小该如何选取。理想情况下，时间片的选取越小，任务响应的时间就越快。但是，之前的讨论分析是基于抽象的模型进行的，没有考虑一下因素: 调度器的调度开销；任务切换所导致的上下文切换开销。在实际场景中，过小的时间片反而会引入大量开销，让任务的调度成为严重的性能瓶颈。而如果任务的调度时间过长，则会产生很多不良的负面效果
    - <span style="color: red;">如何将调度的时间片降低到一个合理的值是对于开发者一个大挑战</span>
    - <span style="color: blue;">弊端 : 在任务允许时间相似的场景下平均周转时间高 <span style="color: black;">RR策略一定程度上保证了每个人物之间的公平性( 每个任务都能在一定时间内被调度到 ),同时也可以获得良好的响应时间。</span></span>

* * *

### 优先级调度

- **调度器应该尽量避免与交互式任务被批处理任务阻塞**。
    - 例 ： 小凡在他的linux操作系统上输入了 一个 ls -R 命令，但此时他的后台挂载着一个大型的服务器，而这个服务器和这个 ls 命令 采取了 RR 的策略，那么小凡就会看到了他的 命令要运行很长时间，暴躁的小凡同学对此很生气，他恨不得立马 kill 了这个进程。
- 如果操作系统可以区分交互式任务和批处理任务，那么他就可以设置一个让交互式任务先执行的一个调度策略。为此，调度器引入了<span style="color: red;"><span style="color: red;">优先级<span style="color: black;">的概念。优先级是一个很直接有效的概念。操作系统通过对优先级的判断来去先执行哪个应用程序，再去执行哪个应用程序，从而达到对用户更好的体验。
    ![](https://raw.githubusercontent.com/yangxiaofan369/img_HMStrange/master/gnome-shell-screenshot-MON5C1.png)</span></span></span>
    - 对于拥有明确的截止时间的完成任务，我们应该为其分配最高的优先级，尽量保证实时任务可以在截止时间之前就可以完成，而交互式的任务响应时间直接影响用户体验，为了避免用户体验较差，我们需要为其分配较高的优先级，最后，批处理任务一般不像实时任务那样需要对时延，响应时间有很大的要求，所以这类任务的优先级很低。

* * *

#### <span style="color: red;">多级队列</span>

- 在一架飞机准备起飞时，人员分为三类，{ 飞行员，空乘，维护人员 }，{ VIP乘客}，{ 普通乘客 } 。在飞机允许登机之前，第一类的工作人员会在专用机场等待。VIP乘客一般会在VIP候机室等待。而工作人员需要立即登机检查人机，做好飞机的临时起飞工作。这三类人在不同的场景下调度。就好像操作系统将不同优先级的任务放在不同的任务队列中。对于优先级仙童的人员，他们的登机顺序没有要求。乘客直接排队( 先到先得 )的方式决定相互之间的登机顺序。
- **多级队列**( Multi-Level Queue, MLQ )策略就是以类似的思想进行设计的，
    - 如图 6-11 所示。每个任务会被分配预先设置好的优先级，每个优先级对应一个队列，任务会被存储在对应的优先级队列中。如果优先级不同的任务的任务同时处于预备状态。那么调度器应该倾向于调度优先级高的任务。
    - 并且一个任务必须等到所有优先级比他高的任务调度完成之后才能被调度。处于相同优先级队列的任务，他们内部的调度方式没有统一标准，可以针对性地为不同队列采用不同调度策略。
        ![](https://raw.githubusercontent.com/yangxiaofan369/img_HMStrange/master/gnome-shell-screenshot-EELBD1.png)
    - MLQ 策略适合静态的引用场景，这类场景下任务信息( 例如任务的大致运行时间，资源使用情况等 )可以在执行前获知。
    - 在设置 MLQ 策略的任务优先级时，需要注意将 IO 密集型任务混合运行的场景，假设计算密集型任务优先级比 IO 密集型任务优先级高。那么就很可能遇到一下这种情况。
        - 大量的高优先级的的计算密集型任务优于 IO 密集型任务执行，而IO密集型任务一直没有机会发起IO请求，必须等到所有计算密集型任务完成之后才可以执行，最终造成 IO 资源利用率低下。由于 IO 密集型任务一般不会消耗大量的 CPU 资源，完全可以提高他的优先级，率先发起 IO 请求，充分利用空闲的 IO 资源。
    - MLQ策略是一种搞笑的优先级调度策略。由于队列的数量一般是预先确定的，调度器可以在 O (1)时间内( 相对于任务总量 N )找到所有非空队列中优先级最高的那一个。并且选取他的队列头的任务进行调度。同时，MLQ调度可以如实地反映任务的优先级。然而，这也可能带来一些问题。
        - 然而这也会带来一些问题:
            - 低优先级任务饥饿。任务优先级较低的任务可能需要等待很长的时间才能够被执行。
            - 所以为了避免 MLQ 策略所带来的低优先级饥饿，需要额外的机制监控任务等待时间，为等待时间过长( 如超过一定阈值 )的任务提高优先级。
    - **优先级反转** ( priority inversion )
        - 在程序执行时，多个任务可能会对同一份数据产生竞争，因此任务会使用锁来保护共享数据。假设现在有 3 个任务 A，B，C，他们的优先级 A > B > C,任务 C 在运行时持有一把锁，然后他被高优先级的任务 A 抢占了( 任务C的锁没有被释放)，此时，任务 B，C都处于可以运行的状态。由于任务 B 的优先级高于 C，因此 B 先运行。
            - 综合来看，我们会发现，任务 B 好像优先级是高于 任务级 A。
            - 优先级继承 ( **priority inheritance** )，在上面的例子中，任务 A 可以把自己的优先级转移给占有锁的任务 C，让任务 C 优先执行并放锁。之后，任务 A 可在任务 C放锁后以抢占的方式立即执行，从而避免了优先级反转的问题。

### 多级反馈队列

随着计算机的发展，操作系统中的任务需求变得越来越复杂。任务同时希望拥有较低的周转时间和响应时间。并且任务的运行时间无法预知。

- 此时一个人站出来了 ==图灵奖==获得者 Corbatoo 领导了 相容分时系统 ( Compatible Time-Sharing System, CTSS )的研发。并于1962年提出了多级反馈队列。
    -多级反馈队列的目标是 ：在无法预知任务信息且任务类型动态变化( 任务行为模式会在计算密集型与 IO 密集型之间转换 )的场景下，既能到达类似 STCF 的策略的周转时间，又能像 RR 策略一样尽可能降低任务的响应时间。MLFQ 策略在 MLQ 策略之上增加了动态设置任务优先级的策略。
    - 与 MLQ 策略类似，MLFQ 策略也会维护多个优先级队列，任务根据优先级存在于不同的队列中，高优先级任务先于低优先级任务执行，处于相同优先级的任务采用 RR 策略执行。MLFO 策略的一大创新是实现了优先级的动态设置，具体策略如下:
        - 段任务拥有更高的优先级。MIFO策略倾向于给更短任务更高的优先级。主要有以下三点好处 :
            - 1.  优先调度短任务可以有更好的平均周转时间。
            - 2.  IO 密集型任务一般在 CPU 中执行的时间更短，给短任务提高优先级也相当于提高 IO 密集型任务的优先级，有利于提高系统的 IO 资源利用率。
            - 3.  交互式任务一般是短任务，提高其优先级有助于降低这些任务的响应时间。
        - MLFQ 策略会首先对任务的运行时间进行评估，预计运行时间较短的任务会放入优先级较高的队列中。但是，在真实系统中，可能无法准确追踪任务的完成时间和剩余完成时间。这也是 SJF 策略 和 STCF 策略的一大限制。为此，MLFQ会统计每个任务已经执行了多长时间，并据此判断该任务是短任务还是长任务。首先，当任务进入系统时，MLFQ会假设该任务是短任务，为其设置最高优先级。这有利于交互式任务达成较短的响应时间以及 IO 密集型任务充分利用 IO 资源。然后，MLFQ会为每个任务队列设置任务的最大运行时间( 任务多次运行的总时间，而非时间片 )。如果任务在当前队列运行的总时间最终超过了队列允许的最大时间。MLFQ策略会认为该任务是运行时间较长的任务，进而将该任务的优先级减一。凭借该方法，MLFQ 就可以大致适配任务的优先级，即动态评估任务的运行时间。由于短任务一般都可以在预设的时间片内完成，因此可以一直保留在优先级较高的队列中；相对地，长任务的优先级则会随着执行次数的增多而逐渐降低。
            - 1.低优先级的任务采用更长的时间片
            - 2.定时地将所有任务的优先级提升到最高
        - 在 MLFQ 策略的具体实现中，就有许多调度参数需要调整，例如优先级队列的数量，每个优先级队列采用的时间片，任务在每个优先级队列的最大运行时间，调度器定时地提升优先级的时间间隔。如果参数使用不当，就可能达不到预期的调度效果。比如，如果提升优先级的时间间隔过段，那么所有任务都会保持在最高的优先级的队列中， MLFQ 策略退化为 RR策略；而如果间隔时间过长，很可能会导致长任务保持在最低优先级队列中，很长时间内无法执行。因此，虽然MLFQ调度策略的设计非常巧妙，但开发者仍然需要话费很大的努力，对系统整体有细致的了解，才可以实现出有效的基于 MLFQ 策略的调度器。
        - <span style="color: red;">MLFQ 策略**通过记录任务运行时间的方式，动态地调配任务的优先级**<span style="color: black;">。他能达到与 SJF 策略 和 SCTF 策略类似的低平均周转时间，同时还能保证任务的响应时间，且能避免任务饥饿。以 MLFQ 为基础的调度策略在很多操作系统中都得到了应用。</span></span>

* * *

### <span style="color: blue;">公平共享策略</span>

- 这类调度器会量化人物对系统资源的占有比例，从而实现对资源的公平调度。我们将以**份额**来量化每个任务对 CPU 的时间的使用。