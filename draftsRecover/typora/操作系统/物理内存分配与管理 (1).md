## 物理内存

- 物理内存分配设计有两个重要的评价维度，一方面，物理内存分配器需要追求更高的内存资源利用率，即尽可能减少资源浪费。这里先介绍**内存碎片**的概念，
- 内存脆片 : 内存碎片指的是无法被利用的内存，其直接导致内存资源利用率的下降。
- 如何减少内存碎片是内存分配器设计者最关心的一个问题。内存碎片又被分为**内部碎片** ( external fragmentation ) 和**外部碎片** ( internal fragmentation )
- 一种解决方式是，将物理内存以固定大小( 能够满足最大分配请求 ）划分为若干块，然后每次用一个块服务一个分配请求。如此一来，外部碎片的问题看似迎刃而解，但又会导致严重内部碎片问题。例如，我分配的内存大于一个应用程序所需要的内存。
- 同时，物理内存分配器要追求更好的性能，主要是尽可能降低分配延迟和节约CPU资源，通过精密的算法细致地解决碎片问题。
    - 如果通过精密的算法细致的解决碎片问题固然能够有效的提高内存资源利用率，但却可能带来高昂的性能开销。

* * *

### 伙伴系统

伙伴系统( buddy system ) 在现代操作系统中被广泛地用于分配连续的物理内存页。其基本思想就是将物理内存划分成连续的块，以块作为基本单位进行分配。不同块的大小可以不同，但每个块都由一个或者多个连续的物理页组成。物理页的数量必须是 2 的 n 次幂。

- 当一个请求需要分配 m 个物理页时，伙伴系统将寻找一个大小合适的块，该块包含 2 ^ n 个物理页，且满足 2^(n-1) < m <= 2^n,在处理请求的过程中，大的块可以分裂成两半，即两个小一号的块，这两个块互为伙伴，分裂得到块可以继续分裂，直到得到一个大小合适的块去服务相应的分配请求。在一个块被释放之后，分配器会找到其伙伴块，若伙伴块也处于空闲的状态，那么就将这两个伙伴块合并，形成一个大一号的空闲块，然后继续尝试向上合并。
    ![](https://raw.githubusercontent.com/yangxiaofan369/img_HMStrange/master/2021-11-18%20214507.png)
- 关于伙伴系统的具体实现，我们了一般采用空闲链表数组来实现伙伴系统。

```c
// 伪代码
#define memory_size 10
typedef struct{
    int number;		//数组编号
    void* ptr;		// 所指向的块的首地址
}memory_ptr;
memory_ptr nums[ memory_size ];
```

- 然后通过一系列的操作来玩成。
    ![](https://raw.githubusercontent.com/yangxiaofan369/img_HMStrange/master/2021-11-18%20215834.png)

* * *

### SLAB 分配器

伙伴系统最小的分配单位是一个物理页( 4 KB),但是在大多数情况下，内核需要分配的内存大小通常是 几十个字节 或者几百个字节。远远小于一个 物理页的大小。如果使用伙伴系统进行内存分配，那么会出现严重的内部碎片问题。从而导致内存资源利用率降低。

```
于是操作系统开发人员设计了另外一套内存分配机制用于分配小内存。
在历史的演变中，现在主流的是 SLUB 分配器和 SLOB 分配器(SLUB分配
器已经成为 Liunx内核默认使用的分配器，SLOB分配器主要应用于内存稀
缺场景，例如嵌入式。
```

- 简单来说，SLUB 分配器做的事情就是把伙伴系统分配的大块内存进一步细分成小块内存进行管理。一方面由于操作系统频繁分配的对象大小相对比较固定，另一方面就是为了避免外部碎片问题。所以 SLUB 分配器只分配固定大小的内存块。
---
### 常用的空闲链表
- **隐式空闲链表**
	- 该链表的每个元素代表了一块内存区域，内存块头部存储了该块是否空闲，块大小的问题。再分配空闲块的时候，分配器在这条链表中依次查询，找到第一块大小足够的空闲内存块即可返回。如果找到的空闲块不仅仅能够满足分配请求，那么就会分裂。
- **显式空闲链表**
	- 显式空闲链表仅仅把空闲的内存块放在链表中，分配器仅仅需要维护两个指针，一个prev和next即可。 
- **分离空闲链表**
	- 分离空闲链表主要是维护多条显式链表， 但每条链表服务固定范围大小的分配请求。
---
### 物理内存和 CPU 缓存
- 在前面我们学习了，计算机为了加速我们程序的运行，所以在存储结构上分了很多层。
- 但是一台普通的服务器的物理内存就有几百 GB ,但是 CPU 的缓存 却只有 几十 MB，物理内存中的数据会根据物理地址以缓存行 ( cache line ) 为 粒度 放入 CPU 缓存中，若缓存已满或存在冲突，则会根据预设的替换策略换掉某个缓存行。