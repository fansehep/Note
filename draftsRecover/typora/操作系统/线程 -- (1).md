引言 : 在早期操作系统中，进程就是操作系统用来管理运行程序的最小单位。随着电子技术的发展，计算机拥有了更多的 CPU 核心，程序的可并行度提高，但是进程这层抽象又显得过于笨重。
- 创建进程的开销太大了，
	- 1.创建独立的地址空间.
	- 2. 载入数据和代码段，初始化堆栈等等
	- 3.  即使调用 fork之类的接口创建进程，那么也需要大量的复制操作。
- 由于单个进程彼此独立，各自拥有自己的虚拟地址空间，在进程间进行数据共享比较麻烦。<font color = blue>传统的共享虚拟页( 粒度较粗 ) <font color = black> 和 <font color = red > 进程间通信 (管道，本地套接字，信号，内存映射文件(mmap) )这些开销都太高<font color = black>，
- 所以研究人员就在进程内部添加可独立执行的单元，他们共享进程间的地址空间，但又各自保存运行时所需要的状态(<font color = Fuchsia >上下文切换<font color = black> )，这就是线程。然后线程便取代进程成为操作系统调度和管理程序的最小单位。线程也继承了操作系统为进程定义的部分概念。
----
### 多线程的地址空间布局
![](https://raw.githubusercontent.com/yangxiaofan369/img_HMStrange/master/gnome-shell-screenshot-NYQ1C1.png)
- ** <font color = red > 分离的内核栈与用户栈<font color = black>**
	- 由于每个线程执行相对独立，进程为每个线程都准备了不同的栈，供他们存放临时数据。在内核中，每个线程也有对应的内核栈。当现成饭切换到内核中执行时，他的栈指针也会切换到对应的内核栈
- ** <font color = red > 共享的其他区域<font color = black>**
	- 进程除栈以外的其他区域，由该进程的所有线程共享，包括堆，数据段，代码段等。当同一个进程的多个线程需要动态分配更多内存时( 在 C 语言 中可通过调用malloc函数实现)，他们的内存分配操作都是在同一个堆上完成的，因此malloc的实现需要使用**同步原语**,使每个线程能正确地获取到可用的内存空间。
----
### 用户态线程和内核态线程
```text
根据线程是由用户态应用还是由内核创建与管理，可将线程分为两类:
```
- **用户态线程( user-level thread )**
- **内核态线程( kernel-level thread )**
内核态线程由内核创建，受操作系统调度器直接管理。而用户态线程则是由应用自己创建，内核不可见，因此不直接受系统调度器管理。
	- 与内核态线程相比，用户态线程更加轻量级，创建开销更小，但功能也较为受限。与内核态相关的操作( 系统调用 ) 需要内核态线程协助才能完成。为了实现用户态线程与内核态线程的协作，操作系统会建立两类线程之间的关系，这种关系我们称之为====多线程模型====( multithreading model )。一般来说，多线程模型主要有三种:
		- 1.多对一模型
		- 2.一对一模型
		- 3.多对多模型
![](https://raw.githubusercontent.com/yangxiaofan369/img_HMStrange/master/gnome-shell-screenshot-ND1DD1.png)
- **多对一模型** : 将多个用户态线程映射给单一的内核态线程。这种模型比较简单，但是由于只有一个内核态线程，每次只能有一个用户态线程进入内核。其他用户态线程只能阻塞，随着多核机器的逐步普及，用户态线程的数量也在不断增加，这种模型很难适应这种变化了。<font color = blue> 随着最进几年的应用变得越发复杂，应用内部的调度也开始变得重要，多对一模型又开始得到了应用。<font color = black>
- **一对一模型** : 一对一模型为每个用户态线程映射单独的内核态线程。每个用户态线程只需要注意自己的内核态线程，不用去阻塞其他的用户态线程。<font color = DeepSkyBlue>但是<font color = black>,这其实只不过又是<font color = red>Trade off<font color = black>罢了，一对一的模型的缺点是 : 由于每个用户态线程都对应一个内核态线程，创建内核态线程的开销会随着用户态线程数量的增加而增加。但是呢一般的操作系统都会对用户态线程做出一些限制。
- **多对多模型** : <font color = Fuchsia>多对多模型可以将 N 个用户态线程 映射到 M 个内核态线程中，并且 N > M<font color = black>,我们一般把内核态线程的数量 M 设置为 CPU 的核心数，但是对用户态线程不做限制。多对多模型大概是前两者的模型一个结合体，既减轻了多对一模型中因为内核态线程过少而导致的阻塞问题，也解决了一对一模型中因为内核态线程过多而导致的性能开销过大的问题。====Trade off====,此时，又增加了内核态线程的管理的复杂性。
### 线程控制块与线程本地存储
- 与进程类似，线程也有自己的**线程控制块**( Thread Control Block, TCB), 用于保存自身的信息。<font color = blue>在目前主流的一对一线程模型中，内核态线程和用户态线程会各自保存自己的 TCB<font color = black>，其中，内核态的 TCB 结构与前面介绍的 PCB 相似，会存储线程的运行状态，内存映射，标识符等信息。而用户态 TCB 的结构主要是由线程库所决定。
	- 例如，在linux / c中，我们如果要用到线程之类的知识，那么就必须使用pthread库，而pthread的结构体就是用户态的 TCB，用户态的 TCB 可认为是内核态的扩展，可以用来存储更多与用户态相关的信息。女士们先生们，让我们了解一些一个很重要的功能吧 <font color = red>线程本地存储<font color = black> ( Thread Local Storage, TLS )。
	- 在多线程编程中，可以通过 TLS 实现一个 "一个名字，多份拷贝" ( 与线程数量相同 ) 的全局变量。这样，即使不同的线程在使用该变量时，虽然从代码层次看访问的都是同一个变量。实际上访问的都是该变量的不同拷贝，于是可以很方便的实现<font color = red>线程内部的全局变量<font color = black >。
		- 例如，一个多线程的应用程序可以通过<font color = blue>__thread int count; <font color = black>为每个线程定义变量 count，当某个线程对count赋值时，只会修改自己的拷贝，并不会对其他线程产生影响。在运行过程中，线程库会为每个线程创建结构完全相同的 TLS，保存在内存的不同地址上。在每个线程的 TLS 中，count都处于相同的位置。即每份count的拷贝相对于 TLS 起始位置的偏移量都相等。
		- 由于 TLS 结构的相似性，对 TLS 变量的寻址的实现方式也较为特殊。×86 - 64 使用了 FS 段寄存器来实现 TLS 中变量的寻址。具体来说，当一个线程被调度时，pthread线程库会找到该线程 TLS 的起始地址，并且存入段寄存器 FS中，当线程访问 TLS 的变量时，会用 FS 中的值加上偏移量的方式获取变量。不同线程的 FS 寄存器中保存的 TLS 起始地址不同，所以不同的线程访问同名的 TLS 变量时，最终其实都访问了不同的地址。
----
### 线程的基本接口 : 以 POSIX 线程库为例
- 在一对一线程模型中( Linux )中，线程库为应用提供了创建，退出，合并等操作线程的接口。
- 线程创建
```c
int pthread_create(pthread_t* thread, const pthread_attr_t* attr,
							void * (*start_routine) (void* ),
							void* arg );
```
<font color = Fuchsia >一个有趣的现象是pthread_create是通过实现的。<font color = black>
- 在进程(1)中我们知道 clone函数是可以到达精密控制的，今天我就来慢慢揭晓他。
```
const int clone_flags = { CLONE_VM | CLONE_FS 
                         | CLONE_FILES | CLONE_SYSVSEM
                         | CLONE_SIGHAND | CLONE_THREAD 
					  | CLONE_SETTLS | ... };
ARCH_CLONE(&start_thread, STACK_VARIABLES_ARGS, clone_flags,...);
```
- 在 clone 之前，pthread_create 会传入大量的参数以控制 " 进程 "的创建过程。其中一部分参数会使得新创建出的"**进程**"与父进程共享数据，比如 CLONE_VM 就会共享地址空间。通过参数从而共享一系列的代码库，堆，数据，代码等内存部分的共享。但是 CLONE_THREAD 较为特殊，它允许新创建的"**进程** "与clone的调用者从属于同一进程。另外，参数 STACK_VARIABLES_ARGS 则对应新的用户栈的起始地址，由 pthread_create 预先创建。总之，通过这些参数，clone实际上创建了一个属于原进程,与原进程共享大量的数据结构，拥有私有栈的实例，而这个实例就对应一个线程。
- <font color = blue> 下面我们来看看linux线程的演化历史<font color = black>
	- 在早期的Linux中，进程还是调度的基本单位，操作系统并没有对线程提供支持。为了提供 POSIX 线程支持。开始时使用 clone 来创建线程，但是clone原本是用来创建进程的。这就显得 "不伦不类" (适配性较差).后来 Red Hat 公司开发的 Native POSIX Thread Libray ( NPTL )修改了 Linux 内核,在linux 2.6 版本进入了内核主线后，并一直沿用至今。
- <font color = red>线程退出<font color = black>
```c
#include <pthread.h>

void pthread_exit(void* retval );
```
- 其实pthread_exit的调用并不是必须的。当一个线程的主函数( 如上面提到的 start_routine )执行结束时，pthread_exit 将会隐式地调用。不过，pthread_eixt提供了参数retval来表示线程的返回值，用户可以通过对pthread_exit调用来设置返回值。如果 pthread_exit 未被显式地调用，那么线程的主函数的返回值会被设置为线程的返回值。
- <font color = red>让出资源<font color = black>
```c
void pthread_yield(void );
```
- 除了pthread_exit线程退出之外，不接受参数，返回值为该操作执行的结果。实现也很简单。放弃 CPU 资源。该函数一定程度上能优化我们的程序，例如 当一个线程需要等待外部事件时，此时对他的调度没有实际意义，只会浪费 CPU 资源。
- <font color = red>合并操作<font color = black>
- 在多线程协作的场景时，可能会出现线程之间的执行存在相互依赖的情况。因此，线程库会提供合并( join )操作，允许一个县城等待另一个线程的执行，并获取他的执行结果。举例来说，当主线程创建了很多工作线程之后，就可以通过调用合并操作获取各工作线程的返回值。判断其执行是否出错。并进行相应的处理
```
int pthread_join(pthread_t thread, void** retval);
/*
	pthread_t thread 参数用于传入需要等待的进程。
	void** retval 则是一块内存，用于接受被等待线程的返回值。该返回值就
是调用 pthread_exit 时设定的返回值。
	pthread_join 将会从被等待线程的内存拷贝到当前线程指定的地址。
*/
```
#### 挂起与唤醒
- 当线程发现自己的执行需要等待某个外部事件时，他便可以加入阻塞状态，让出计算资源给其他线程执行。使线程进入阻塞状态的机制我们称之为**挂起**。线程的挂起一般有两种方式
	- 1. <font color = red>等待固定的时间<font color = black>
		- sleep 函数会让线程挂起数秒。如果需要更加细粒度的控制，则可以使用nanosleep函数(纳秒),当sleep被调用时，内核会将对应的线程状态设置为阻塞。当 sleep 指定的时间走完后，内核会将该线程重新唤醒，重新将其状态改为预备状态，允许它继续执行。由于内核不能保证线程被唤醒后可以立即被调度，因此一般来说，线程从挂起到再次被执行的时间会长于其指定的需要挂起的时间。
	- 2. <font color = Teal>等待具体的事件<font color = black>
		- 第二种就是等待具体的事件,在linux中线程也可以在进入挂起状态之前指明等待的具体事件。在pthreads中，对应的接口是 pthread_cond_wait。
		- pthread_cond_wait 使用**条件变量**作为同步的方式，pthread_cond_wait 会让线程等待一个参数 cond 之上。内核会将该线程挂起。当其他线程使用 pthread_cond_signal操作同一个条件变量cond时，内核会协助将挂起的线程唤醒，使他重新变为预备状态。
```c
// sleep 函数
unsigned int sleep(unsigned int seconds );
// pthread_cond_wait 函数
int pthread_cond_wait( pthread_cond_t* restrict cond, 
						pthread_mutex_t* restrict mutex );
```
#### <font color = DarkOrchid> sleep vs pthread_yield<font color = black>
```text
sleep 操作与前面提到的yield有相似之处，他们都会让当前线程放弃CPU资
源，然后交给其他线程执行。他们最重要的区别就是调用后线程的区别:
yield : 当线程调用yield之后，该线程仍然会处于预备状态，并且可能很快就会被调度。在某些极端情况下，如果没有其他可以调度的线程，该线程甚至
会继续执行。
sleep : 当线程调用了sleep之后，他会进入阻塞状态，只有条件满足后才会
重新恢复到预备状态，我们可以把yield看做类似于sleep(0);,就是挂起
时间无限趋于0的调用。

yield由于很快就会被再次调用，因此适合于等待条件很快就会被满足的
情况。
sleep由于会涉及到线程状态的变化，因此适合于等待条件被满足的时间
不确定或者较长的情况。
```



