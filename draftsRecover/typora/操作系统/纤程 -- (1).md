## <font color = Teal>纤程<font color = black>
由于主流的操作系统都采取一对一的线程模型。用户态线程和内核态线程具有一对一的关系。可以认为用户态线程的执行几乎完全收到操作系统调度器的管理。但是随着计算机的发展，应用程序也变得越来越复杂，在这些复杂的应用程序中，每个线程<font color = red>各司其职<font color = black>,有的负责计算，有的负责网络通信，有的大量读写内存。与操作系统调度器相比，应用程序对线程的语义和执行状态更加了解，因此可能做出更好的调度决策。此外用户态线程更利于提高整个程序的可扩展性。在这样的背景下，操作系统开始提供更多对用户态线程，即纤程的支持。
### 对纤程的需求
#### 经典例子<font color = blue> 生产者消费者模型<font color = black>
- 生产者负责"<font color = red>生产<font color = black>"数据，即生成一些用于处理的数据；消费者则负责"<font color = red>消费<font color = black>"数据，就是处理生产者生成的数据。
- <font color = DeepSkyBlue>Example<font color = black>
	- 现在假设一个进程中拥有两个线程，一个生产者，一个消费者，生产者在共享内存中写入数据，消费者从内存中使用。在线程的一次切换需要一次上下文切换( 即生产者到消费者 ),才能完成数据处理。但是在真正的服务器上时，一台计算机跑的程序上千个，调度器并不知道你这两个线程拥有生产者消费者这种关系。有时候并不总是优先生产者开始调度。而且消费者可能需要经历很长的一部分时间才能拿到数据。为了消除这部分延迟，计算机科学家引入了纤程。
#### POSIX的纤程支持
```c
#include <ucontext.h>

int getcontext(ucontext_t*  ucp);
int setcontext(const ucontext_t* ucp);
void makecontext(ucontext_t* ucp, void (*func)(), 
							int argc,....);
/*
	getcontext 可以用来保存当前的上下文，而setcontext则可以用来
切换到另一个上下文。
	setcontext 则用来切换到另一个上下文。
	makecontext 可以创建一个全新的上下文，并将其保存在第一个参数
ucp中。
由于这些上下文属于纤程，因此并不会保存到内核中TCB，而是完全保存在
第一个参数ucp中。由于这些上下文属于纤程，因此并不会保存到内核中
的TCB，而是完全保存在用户态。
*/
```
#### 纤程的上下文切换
- 纤程的上下文切换的触发机制与内核态存在较大不同。由于操作系统可以通过中断的方式抢占当前的 CPU 并进行上下文切换。这种切换是强制的，所以我们一般称之为<font color = red>抢占式多任务处理<font color = black>( preemptive multitasking )模式，但是纤程并不具备使用中断抢占其他纤程的权限，因此无法使用这种模式。所以纤程一般会提供==yield==接口，该接口与一对一模型的yield接口相似，都会暂时放弃 CPU，允许其他纤程的调度。这种调度方式被称为<font color = red>合作式多任务处理<font color = black> ( cooperative multitasking ),需要多个纤程进行协作以完成调度。
- 除了 POSIX 定义的 ucontext 以外，Windows操作系统也提供了对纤程的支持，模型与context类似。(此处不做过多赘述)。
- 除了操作系统以外，很多程序语言也提供对纤程的支持。从操作系统的支持来看，我们一般称之为纤程，一般将程序语言提供的纤程支持称之为<font color = red>协程<font color = black>,现在很多语言都提供了对携程的支持，而这一特性常常被用在上下文频繁切换的应用场景中( Web服务 )。随着应用种类变得复杂，支持协程已经成为程序语言的一大发展趋势。


