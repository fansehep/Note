## Google FileSystem 总结

- 谷歌文件系统是谷歌为了支持自身大流量的服务所定制的文件系统。

- 引言 :

  - 1.  GFS 由成千上百台廉价设备组成的存储节点组成。以及各种bug
    2.  文件比传统标准更大，数GB大小的文件是十分常见的。
    3. 大部分文件会以"append"的方式来进行变更，而非 "overwrite". 
       - 在实际场景中，几乎不存在对文件的随机写入。文件一旦被写入，即为只读的。且通常仅被顺序读取。
    4. 同时设计应用程序和文件系统API便于提高整个系统的灵活性。
       - google 放宽了GFS 的一致性协议，从而大幅度简化了系统。

- 设计概述

  - ...

- 接口

  - ...

- 架构

  ![2022-03-29_15-03-1648540661](/home/fan/Screenshots/2022-03-29_15-03-1648540661.jpg)

  - 文件被划分为了多个固定大小的chunk,  每个chunk 被一个不可变的全局唯一的 64 位 chunk handle 唯一标识。chunk handle 在chunk被创建时由主节点分配。chunkserver 将 chunk 作为 linux 文件存储到本地磁盘中。通过 chunk handle 和 byte range 字节范围 来确定需要被读写的chunk 和 chunk 中的数据。为了可靠性考虑，每个chunk 会在多个chunkserver 中有副本。我们默认存储三份副本，用户也可以为不同的命名空间的域制定不同的副本等级。
  - master 维护系统的所有的元数据。元数据包括命名空间(namespace), 访问控制，(access control) 信息，文件到chunk 的映射和chunk 当前的位置。master  还控制系统级活动如 chunk 租约(chunk lease) 管理，孤儿chunk 垃圾回收，和chunkserver  间的chunk 迁移，master 周期性的通过心跳 heartbeat 消息与每个chunkserver 之间通信，向其下达指令并采集其状态信息。

- 单 master

  - 单 master节点简化设计。
    - 让master可以通过全局的信息做复杂的chunk分配和副本相关的决策。
    - 然而我们必须最小化master节点在读写中的参与，以避免让其成为系统瓶颈。
    - client不会从master读取文件数据，而是询问master他需要与哪个chunkserver通信。
      - client会在一定时间内缓存信息，并且直接与对应的chunkserver通信以完成后续操作。

- 元数据

  - master主要存储三种元数据

    - 1. 文件和chunk 的命名空间
      2. 文件到chunk 的映射
      3. chunk的每个副本的位置
    - 所有元数据被存储在master的内存中
      - 前 2 中类型1 和 2 还通过变更记录到一个操作日志的方式持久化存储到master的磁盘上。并在远程机器上备份。
      - 通过日志，我们可以简单，可靠地更新master节点的状态，即使master故障也没有数据不一致的风险。
      - master不会持久化存储 chunk 的位置信息，而是在启动时和当chunkserver 加入集群时向 chunkserver 询问其存储的chunk  信息。

  - 内部数据结构

    - master不会持久化保存哪太 chunkserver 含有给定的chunk 的副本的记录，而是简单的启动时从 chunkserver  获取信息。随后，master 就可以保证自己的记录是最新的。因为 master 控制着所有的chunk 的分配并通过周期性的心跳消息监控 chunkserver 状态。

  - 操作日志

    - master 通过重放replay 操作日志来恢复其文件系统的状态。操作日志要尽可能小以减少启动时间。
    - 当日志超过一定大小时，master会对其状态创建一个检查点。这样 master 就可以从磁盘加载最后一个检查点并重放该检查点后的日志来恢复状态。
    - 因为创建一个检查点需要一段时间，所以master可以被设计为在不推迟新到来的变更的情况下创建检查点。

  - GFS 提供的保障

    - 由于一切的请求都会先给向master, 他们仅由master处理，命名空间锁保证了原子性和正确性。

    - 1. 一致的 "Consistent" , 这个是说，多个客户端无论是从主副本读取数据，还是从次副本读取数据，独到的数据都是一样的。

      2. 确定的 "Defined", 这个会高一些，值的是对于客户端写入到 GFS 的数据，能够完整地被读到。

         |              | 写入             | 记录追加                   |
         | ------------ | ---------------- | -------------------------- |
         | 顺序写入成功 | 确定             | 确定，但夹杂着不确定的数据 |
         | 并发写入成功 | 一致的但并非确定 | 确定，但夹杂着不确定的数据 |
         | 写入失败     | 不一致           | 不一致                     |

         - 如果写入失败，由于一个chunk 会有另外两个 chunk 副本，主副本的写入会将写入指令发到两个次副本，如果次副本写入失败了，那么此时其他的客户端所读到的数据就是不一致的。
         - 如果客户端的数据写入是顺序的，并且写入成功了，那么文件里面的内容就是确定的。
         - 如果多个客户端同时写入，那么文件里面的内容就是不确定的。

  - 系统交互

    - 当我们改变chunk里面的内容时，每个chunk的副本都应该发生改变。
    - 我们使用 租约 (lease) 来维护副本间变更顺序的一致性。
    - master向其中一份副本授权一个变更的租约。我们称之为 primary.
    - primary 为应用于该 chunk 的所有变更选取顺序。所有副本都会按照这个顺序来应用变更。
      - 因此，全局的变更顺序首先由 master 选取的租约授权顺序定义，接着在租约内由 primary 选取的顺序编号定义。
      - 这种租约机制是为了最小化master管理负载而设计的。租约的初始超时时间为 60s, 然而，一旦chunk被变更，primary 就可以向 master 请求延长租约时间，或者(通常为)接受来自 master 的租约时间延长操作。这些租约延长请求依赖于 master 与 chunkserver 间周期性地心跳消息来实现。有时master可能会在租约过期前试图撤销租约(). 即使 master 与一个 primary 的通信丢失，master 仍可以在旧租约过期后安全地向另一个副本授权新的租约。